#!/usr/bin/env bash

# upload-secrets
#
# upload secrets to HashiCorp Vault server
#
# author  : stefan schablowski
# contact : stefan.schablowski@desmodyne.com
# created : 2018-07-07


# TODO: must run 'git secret reveal -f' in target repo to access clear text secrets


# -----------------------------------------------------------------------------
# determine platform: http://stackoverflow.com/a/18434831

case "${OSTYPE}" in
    darwin*)
        grep='ggrep'
        ;;
    linux-*)
        grep='grep'
        ;;
    *)
        echo "Unsupported operating system: ${OSTYPE}"
        exit 1
        ;;
esac


# -----------------------------------------------------------------------------
# define functions

# http://stackoverflow.com/a/6212408

function usage
{

    # TODO: do not use global variables
    # TODO: space between << and 'EOT' makes a
    # difference for atom syntax highlighting
    # TODO: align properly and remove leading space when printing ?

    read -r -d '' msg_tmpl <<'EOT'
Usage: %s <config file> <secrets folder>

mandatory arguments:
  config file           path to configuration file
  secrets folder        path to folder with secrets
secrets folder is typically a repository / project root folder

optional arguments:
  -?, --help            print this help message
EOT

    # shellcheck disable=SC2059
    printf "${msg_tmpl}\\n" "${script_name}"
}


# -----------------------------------------------------------------------------
# process command line arguments

# name of this script: http://stackoverflow.com/q/192319
script_name="$(basename "$0")"

if [ $# -ne 2 ]
then
    usage
    exit 1
fi

# http://stackoverflow.com/a/14203146
while [ $# -gt 0 ]
do
    key="$1"

    case "${key}" in
      # NOTE: must escape -?, seems to act as wildcard otherwise
      -\?|--help) usage; exit 1 ;;

      *)  if   [ -z "${config_file}" ]
          then
              config_file="$1"
          elif [ -z "${secrets_folder}" ]
          then
              secrets_folder="$1"
          else
              usage
              exit 1
          fi
    esac

    # move past argument or value
    shift
done

# TODO: try to use ~/.<script_name>.yaml or so if no config file is passed ?

# verify mandatory command line arguments were passed
if [ -z "${config_file}" ] || [ -z "${secrets_folder}" ]
then
    usage
    exit 1
fi

if [ ! -e "${config_file}" ]
then
    echo "${config_file}: No such file or directory"
    exit 1
fi

if [ ! -r "${config_file}" ]
then
    echo "${config_file}: File is not readable"
    exit 1
fi

if [ ! -e "${secrets_folder}" ]
then
    echo "${secrets_folder}: No such file or directory"
    exit 1
fi

if [ ! -r "${secrets_folder}" ]
then
    echo "${secrets_folder}: Folder is not readable"
    exit 1
fi


# -----------------------------------------------------------------------------
# configure script parameters

# absolute path to this script: http://stackoverflow.com/a/9107028
path_to_this_script="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# path from this script to project root
rel_path_to_project_root='../..'

# absolute path to project root
path_to_project_root="$(realpath \
                        "${path_to_this_script}/${rel_path_to_project_root}")"


# -----------------------------------------------------------------------------
# load script configuration

# NOTE: see config file for parameter documentation
# TODO: error handling, e.g. check if json / yaml keys are available

# http://mikefarah.github.io/yq
# NOTE: this essentially converts YAML to JSON
config="$(yq r -j "${config_file}")"

# NOTE: without -r, double quotes around values might cause tools to fail
secrets_suffix="$(jq -r '.secrets_suffix' <<< "${config}")"
line_regex="$(    jq -r '.line_regex_up' <<< "${config}")"


# -----------------------------------------------------------------------------
# upload secrets to HashiCorp Vault server


if ! pushd "${path_to_project_root}" > /dev/null
then
    echo "Failed to pushd to project root ${path_to_project_root}"
    exit
fi


echo -n 'scan for secrets files: '

if output="$(find "${secrets_folder}" -name "*${secrets_suffix}" 2>&1)"
then
    echo 'OK'
    find_output="${output}"
else
    echo 'ERROR'
    echo "${output}"
    exit 1
fi

echo 'extract location and secret:'

OLD_IFS="${IFS}" && IFS=$'\n'

for filename in ${find_output}
do
    # full path to unencrypted secrets file
    unenc_path="${filename%${secrets_suffix}}"

    if [ ! -e "${unenc_path}" ]
    then
        echo "failed to find unencrypted version of ${filename}"
        echo "you might have to run 'git secret reveal -f' in secrets repo"
        exit 1
    fi

    lines=$(<"${unenc_path}")
    for line in ${lines}
    do
        if ! "${grep}" -Eq "${line_regex}" <<< "${line}"
        then
            echo "line ${line} in ${unenc_path} does not match expected pattern"
            exit 1
        fi

        secret_name="$( cut -d '=' -f 1 <<< "${line}")"
        secret_value="$(cut -d '=' -f 2 <<< "${line}")"

        # TODO: does this line in file matter ?
        echo "secret location : ${unenc_path}"
        echo "secret name     : ${secret_name}"
        echo "secret value    : ${secret_value}"
        echo
    done
done

IFS="${OLD_IFS}"


if ! popd > /dev/null
then
    echo "Failed to popd from project root ${path_to_project_root}"
    exit
fi
