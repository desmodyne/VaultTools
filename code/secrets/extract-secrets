#!/usr/bin/env bash

# extract-secrets
#
# scan directory for secrets and mirror the files that contain them
#
# author  : stefan schablowski
# contact : stefan.schablowski@desmodyne.com
# created : 2018-07-06


# -----------------------------------------------------------------------------
# determine platform: http://stackoverflow.com/a/18434831

case "${OSTYPE}" in
    darwin*)
        grep='ggrep'
        sed='gsed'
        ;;
    linux-*)
        grep='grep'
        sed='sed'
        ;;
    *)
        echo "Unsupported operating system: ${OSTYPE}"
        exit 1
        ;;
esac


# -----------------------------------------------------------------------------
# define functions

# http://stackoverflow.com/a/6212408

function usage
{

    # TODO: do not use global variables
    # TODO: space between << and 'EOT' makes a
    # difference for atom syntax highlighting
    # TODO: align properly and remove leading space when printing ?

    read -r -d '' msg_tmpl <<'EOT'
Usage: %s <config file>

mandatory arguments:
  config file           path to configuration file

optional arguments:
  -?, --help            print this help message
EOT

    # shellcheck disable=SC2059
    printf "${msg_tmpl}\\n" "${script_name}"
}


# -----------------------------------------------------------------------------
# process command line arguments

# name of this script: http://stackoverflow.com/q/192319
script_name="$(basename "$0")"

if [ $# -ne 1 ]
then
    usage
    exit 1
fi

# http://stackoverflow.com/a/14203146
while [ $# -gt 0 ]
do
    key="$1"

    case "${key}" in
      # NOTE: must escape -?, seems to act as wildcard otherwise
      -\?|--help) usage; exit 1 ;;

      *)  if [ -z "${config_file}" ]
          then
              config_file="$1"
          else
              usage
              exit 1
          fi
    esac

    # move past argument or value
    shift
done

# TODO: try to use ~/.<script_name>.yaml or so if no config file is passed ?

# config file is a mandatory command line argument
if [ -z "${config_file}" ]
then
    usage
    exit 1
fi

if [ ! -e "${config_file}" ]
then
    echo "${config_file}: No such file or directory"
    exit 1
fi

if [ ! -r "${config_file}" ]
then
    echo "${config_file}: File is not readable"
    exit 1
fi


# -----------------------------------------------------------------------------
# configure script parameters

# absolute path to this script: http://stackoverflow.com/a/9107028
path_to_this_script="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# path from this script to project root
rel_path_to_project_root='../..'

# absolute path to project root
path_to_project_root="$(realpath \
                        "${path_to_this_script}/${rel_path_to_project_root}")"


# -----------------------------------------------------------------------------
# load script configuration

# NOTE: see config file for parameter documentation
# TODO: error handling, e.g. check if json / yaml keys are available

# http://mikefarah.github.io/yq
# NOTE: this essentially converts YAML to JSON
config="$(yq r -j "${config_file}")"

# NOTE: without -r, double quotes around values cause grep to fail with code 2
source_folder="$(jq -r '.source_folder' <<< "${config}")"
target_folder="$(jq -r '.target_folder' <<< "${config}")"
secrets_regex="$(jq -r '.secrets_regex' <<< "${config}")"
line_regex="$(   jq -r '.line_regex'    <<< "${config}")"


# -----------------------------------------------------------------------------
# extract secrets from target project


if ! pushd "${path_to_project_root}" > /dev/null
then
    echo "Failed to pushd to project root ${path_to_project_root}"
    exit
fi


echo -n 'scan for lines that possibly contain secrets: '

# NOTE: GNU grep seems _massively_ faster that macOS / BSD grep
# NOTE: if source_folder doesn't exist, grep fails without error message
# might have to add -s switch to (BSD ?) grep to suppress error message
if output="$("${grep}" -EHnr "${secrets_regex}" "${source_folder}" 2>&1)"
then
    echo 'OK'
    grep_output="${output}"
else
    echo 'ERROR'
    echo "${output}"
    exit 1
fi

echo 'extract location and secret:'

OLD_IFS="${IFS}" && IFS=$'\n'

for line in ${grep_output}
do
    if "${grep}" -Eq "${line_regex}" <<< "${line}"
    then
        source_path="$( "${sed}" -E "s|${line_regex}|\1|g" <<< "${line}")"
        source_line="$( "${sed}" -E "s|${line_regex}|\2|g" <<< "${line}")"
        secret_name="$( "${sed}" -E "s|${line_regex}|\3|g" <<< "${line}")"
        secret_value="$("${sed}" -E "s|${line_regex}|\4|g" <<< "${line}")"

        path_into_project="${source_path#$source_folder}"
        # TODO: need to remove leading / - do this in one line ?
        path_into_project="$(dirname  "${path_into_project:1}")"
        target_filename="$(  basename "${source_path}")"

        echo "secret location : ${source_path}:${source_line}"
        echo "secret name     : ${secret_name}"
        echo "secret value    : ${secret_value}"

        output_folder="${target_folder}/${path_into_project}"
        output_path="${output_folder}/${target_filename}"
        mkdir -p "${output_folder}"
        touch "${output_path}"

        if "${grep}" -q "${secret_name}=${secret_value}" "${output_path}"
        then
            echo 'secret exists'
        else
            echo "${secret_name}=${secret_value}" >> "${output_path}"
            echo 'secret added'
        fi

        echo
    fi

done

IFS="${OLD_IFS}"


if ! popd > /dev/null
then
    echo "Failed to popd from project root ${path_to_project_root}"
    exit
fi
