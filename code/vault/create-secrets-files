#!/usr/bin/env bash

# create-secrets-files
#
# generate configuration files for vault secrets in secure location
#
# author  : stefan schablowski
# contact : stefan.schablowski@desmodyne.com
# created : 2018-02-22


echo
echo 'Create HashiCorp Vault secrets files'
echo


# -----------------------------------------------------------------------------
# load functions from library and run as appropriate

# see also build-vault

source vault.lib

if ! determine_platform;            then exit 1; fi
if ! proc_cmd_line_args "$@";       then exit 1; fi


# -----------------------------------------------------------------------------
# load script configuration

# NOTE: see config file for parameter documentation
# TODO: error handling, e.g. check if path_to_sec_loc is available
# TODO: review output, message only if error or -v / --verbose

# http://mikefarah.github.io/yq
config="$(yq -j r "${config_file}")"

# TODO: align with PKI scripts, get the first two from Ansible group vars

mgmt_user_name="$(     jq -r '.mgmt_user_name'      <<< "${config}")"
organization="$(       jq -r '.organization'        <<< "${config}")"
path_to_pki_folder="$( jq -r '.path_to_pki_folder'  <<< "${config}")"
path_to_sec_loc="$(    jq -r '.path_to_sec_loc'     <<< "${config}")"
path_to_tmpl_folder="$(jq -r '.path_to_tmpl_folder' <<< "${config}")"
secrets_folder="$(     jq -r '.secrets_folder'      <<< "${config}")"
placeholder="$(        jq -r '.placeholder'         <<< "${config}")"

# compound configuration sections
secrets_json="$(       jq -r '.secrets'             <<< "${config}")"

# TODO: review jq exprs to make these scalable beyond one path

# json data structure with secrets for each service
serv_secrets="$(jq '.[] | select(.context=="service")' <<< "${secrets_json}")"

# json data structure with secrets for each user
user_secrets="$(jq '.[] | select(.context=="user")'    <<< "${secrets_json}")"


# -----------------------------------------------------------------------------
if ! validate_config_settings;      then exit 1; fi


# -----------------------------------------------------------------------------
# configure script parameters

# absolute path to this script: http://stackoverflow.com/a/9107028
path_to_this_script="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# path from this script to project root
rel_path_to_project_root='../..'

# absolute path to project root
path_to_project_root="$(realpath \
                        "${path_to_this_script}/${rel_path_to_project_root}")"

# absolute path to folder with secrets configuration files
# TODO: with the current config, this results in /opt/vault/secrets/secrets/
path_to_secrets_folder="${path_to_sec_loc}/${secrets_folder}"

# name of service secret template file
srv_sec_tmpl='service_secret.yaml.j2'

# name of user secret template file
user_sec_tmpl='user_secret.yaml.j2'

# organization name is used in lower case
organization="$(tr '[:upper:]' '[:lower:]' <<< "${organization}")"

# template for managent user private ssh key filename
# sample name: id_rsa_desmodyne_ansible_ssc_rs
mgmt_key_filename_tmpl="id_rsa_${organization}_${mgmt_user_name}_%s_rs"

# template for personal private ssh key filename
# sample name: id_rsa_desmodyne_ssc_rs
pers_key_filename_tmpl="id_rsa_${organization}_%s_rs"

# jq expression template to get service secrets from existing secrets file
# NOTE: secret/user/ must be in sync with .../data/tmpl/user_secret.yaml.j2
jq_expr_tmpl_serv='.[] | from_entries | .secrets | from_entries | .%s'

# jq expression template to get user passwords from existing secrets file
# NOTE: secret/user/ must be in sync with .../data/tmpl/user_secret.yaml.j2
jq_expr_tmpl_user='.[] | from_entries | select(.path=="secret/user/%s") '
jq_expr_tmpl_user+='| .secrets | from_entries | .password'


# -----------------------------------------------------------------------------
if ! validate_secure_location;      then exit 1; fi


# -----------------------------------------------------------------------------
# create secrets configuration file


if ! pushd "${path_to_project_root}" > /dev/null
then
    echo "failed to pushd to project root ${path_to_project_root}"
    exit
fi


if [ ! -d "${path_to_secrets_folder}" ]
then
    echo -n 'create secrets configuration folder: '
    if output="$(mkdir -p "${path_to_secrets_folder}" 2>&1)"
    then
        echo 'OK'
    else
        echo 'ERROR'
        echo "${output}"
        exit 1
    fi
fi

# TODO: continue or exit ?
# TODO: remove code duplication

if [ -z "${serv_secrets}" ]
then
    echo 'no services configured; skip creating service secrets files'
else
    serv_names="$(jq -r '.sec_confs[].path' <<< "${serv_secrets}" | xargs)"
fi

for serv_name in ${serv_names}
do
    echo "service ${serv_name}:"

    # secrets json data structure as obtained from conf file:
    #   "secrets":
    #   [
    #     "admin_password",
    #     "reader_password",
    #     "user_password",
    #     "root_password"
    #   ]
    #
    # secrets json data structure as needed to render template:
    #   "secrets":
    #   {
    #     "admin_password": <existing password> or <placeholder> (i.e. "TODO"),
    #     "reader_password": <existing password> or <placeholder> (i.e. "TODO"),
    #     "user_password": <existing password> or <placeholder> (i.e. "TODO"),
    #     "root_password": <existing password> or <placeholder> (i.e. "TODO")
    #   }

    echo -n '  add known secrets to template data: '

    # TODO: do not hard-code file suffix
    path_to_conf_file="${path_to_secrets_folder}/${serv_name}.yaml"

    num_of_sec_confs="$(jq -r '.sec_confs | length' <<< "${serv_secrets}")"

    tmpl_data="${serv_secrets}"

    for index in $(seq 0 "$((num_of_sec_confs - 1))")
    do
        secret_keys="$(jq -r ".sec_confs[${index}].secrets[]" \
                        <<< "${serv_secrets}" | xargs)"

        secrets_json_map='{}'

        for secret_key in ${secret_keys}
        do
            secret_value="${placeholder}"

            # attempt to get secret from existing file
            if [ -f "${path_to_conf_file}" ]
            then
                # shellcheck disable=SC2059
                jq_expr="$(printf "${jq_expr_tmpl_serv}" "${secret_key}")"

                if output="$(yq r -j "${path_to_conf_file}" \
                             | jq -r "${jq_expr}"  2>&1)"
                then
                    secret_value="${output}"
                fi
            fi

            # extend json object:      https://stackoverflow.com/q/31694182
            # parentheses around $key: https://stackoverflow.com/a/35842157
            secrets_json_map="$(jq --arg key   "${secret_key}"    \
                                   --arg value "${secret_value}"  \
                                   '. += { ($key): $value }' \
                                 <<< "${secrets_json_map}")"
        done

        # replace secrets array in template data with secrets object
        tmpl_data="$(jq --argjson secrets "${secrets_json_map}"     \
                        ".sec_confs[${index}].secrets = \$secrets"  \
                      <<< "${tmpl_data}")"
    done

    # add service to template data
    serv_secrets="$(jq --arg  service "${serv_name}" \
                               '. + { service: $service }' \
                                <<< "${serv_secrets}")"

    echo 'OK'

    # TODO: do not hard-code file suffix
    path_to_temp_file="${path_to_secrets_folder}/${serv_name}.yaml.temp"

    echo -n '  render template into configuration file: '
    if output="$(j2 --format json "${path_to_tmpl_folder}/${srv_sec_tmpl}" \
                              <<< "${tmpl_data}" 2>&1)"
    then
        echo 'OK'
        echo "${output}" > "${path_to_temp_file}"
    else
        echo 'ERROR'
        echo "  ${output}"
        exit 1
    fi

    # move temp file to conf file
    if ! output="$(mv "${path_to_temp_file}" "${path_to_conf_file}" 2>&1)"
    then
        echo "${output}"
        exit 1
    fi

    echo "  file created: ${path_to_conf_file}"
done


if [ -z "${user_secrets}" ]
then
    echo 'no users configured; skip creating user secrets files'
else
    user_names="$(jq -r '.[].name' <<< "${user_secrets}" | xargs)"
fi

for user_name in ${user_names}
do
    echo "user ${user_name}:"

    # secrets json data structure as obtained from conf file:
    #   "secrets":
    #   [
    #     "password",
    #     "private_key",
    #     "public_key"
    #   ]
    #
    # secrets json data structure as needed to render template:
    #   "secrets":
    #   {
    #     "password": <existing password> or <placeholder> (i.e. "TODO"),
    #     "private_key": "(multi-line!) <private key>"
    #     "public_key": "<public key>",
    #   }

    echo '  add known secrets to template data:'

    # TODO: do not hard-code file suffix
    path_to_conf_file="${path_to_secrets_folder}/${user_name}.yaml"

    num_of_sec_confs="$(jq -r '.sec_confs | length' <<< "${user_secrets}")"

    tmpl_data="${user_secrets}"

    for index in $(seq 0 "$((num_of_sec_confs - 1))")
    do
        # TODO: print loop variable

        password="${placeholder}"

        secret_keys="$(jq -r ".sec_confs[${index}].secrets[]" \
                        <<< "${user_secrets}" | xargs)"
        secret_path="$(jq -r ".sec_confs[${index}].path" \
                        <<< "${user_secrets}")"

        if   [ "${secret_path}" = 'null' ]
        then
            # attempt to get user password from existing file
            if [ -f "${path_to_conf_file}" ]
            then
                # shellcheck disable=SC2059
                jq_expr="$(printf "${jq_expr_tmpl_user}" "${user_name}")"

                if output="$(yq r -j "${path_to_conf_file}" \
                             | jq -r "${jq_expr}"  2>&1)"
                then
                    password="${output}"
                fi
            fi

            if [ "${path_to_pki_folder}" != 'null' ]
            then
                # shellcheck disable=SC2059
                path_to_private_key="$(printf \
                  "${path_to_pki_folder}/${pers_key_filename_tmpl}"     \
                  "${user_name}")"
                # shellcheck disable=SC2059
                path_to_public_key="$(printf  \
                  "${path_to_pki_folder}/${pers_key_filename_tmpl}.pub" \
                  "${user_name}")"
            fi

        # NOTE: path must be in sync with .../data/tmpl/user_secret.yaml.j2
        elif [ "${secret_path}" = "shared_users/${mgmt_user_name}" ]
        then
            # attempt to get management user password from existing file
            if [ -f "${path_to_conf_file}" ]
            then
                # shellcheck disable=SC2059
                jq_expr="$(printf "${jq_expr_tmpl_user}" \
                                  "${user_name}/shared_users/${mgmt_user_name}")"

                if output="$(yq r -j "${path_to_conf_file}" \
                             | jq -r "${jq_expr}"  2>&1)"
                then
                    password="${output}"
                fi
            fi

            if [ "${path_to_pki_folder}" != 'null' ]
            then
                # shellcheck disable=SC2059
                path_to_private_key="$(printf \
                  "${path_to_pki_folder}/${mgmt_key_filename_tmpl}"     \
                  "${user_name}")"
                # shellcheck disable=SC2059
                path_to_public_key="$(printf  \
                  "${path_to_pki_folder}/${mgmt_key_filename_tmpl}.pub" \
                  "${user_name}")"
            fi

        else
            echo "    unexpected secrets path ${secret_path}"
            exit 1
        fi

        # re-format private and public key
        # https://stackoverflow.com/a/3182519
        if [ -n "${path_to_private_key}" ]
        then
            tmp_file_contents=$'|\n'
            tmp_file_contents+="$(sed -e 's/^/      /' "${path_to_private_key}")"
            private_key="${tmp_file_contents}"
        fi
        if [ -n "${path_to_public_key}"  ]
        then
            tmp_file_contents=$'|\n'
            tmp_file_contents+="$(sed -e 's/^/      /' "${path_to_public_key}" )"
            public_key="${tmp_file_contents}"
        fi

        # empty secrets json data structure
        secrets_json_map='{}'

        # https://unix.stackexchange.com/a/122848
        for secret_key in ${secret_keys}
        do
            case "${secret_key}" in
                password)
                    secret_value="${password}"
                    ;;
                public_key)
                    secret_value="${public_key:-}"
                    ;;
                private_key)
                    secret_value="${private_key:-}"
                    ;;
                *)
                    echo "    unknown secret key ${secret_key}; ignoring"
                    continue
            esac

            # extend json object:      https://stackoverflow.com/q/31694182
            # parentheses around $key: https://stackoverflow.com/a/35842157
            if [ -n "${secret_value}" ]
            then
                secrets_json_map="$(jq --arg key   "${secret_key}"    \
                                       --arg value "${secret_value}"  \
                                       '. += { ($key): $value }' \
                                     <<< "${secrets_json_map}")"
            fi

        done

        # TODO: is there a jq built-in way to check for empty data ?
        if [ "${secrets_json_map}" != '{}' ]
        then
            # replace secrets array in template data with secrets object
            tmpl_data="$(jq --argjson secrets "${secrets_json_map}"     \
                            ".sec_confs[${index}].secrets = \$secrets"  \
                          <<< "${tmpl_data}")"
        fi
    done

    # tmpl_data was set to user_secrets before the big loop above that
    # iterates over sec_confs; if its value is unchanged, no secret key / value
    # pairs were addedsecrets were added to secrets_json_map and thus no
    # template data was assembled, there is no point in rendering a conf file
    if [ "${tmpl_data}" = "${user_secrets}" ]
    then
        echo '  no usable secrets; file not created'
        continue
    fi

    # add user_name to template data
    tmpl_data="$(jq --arg user_name "${user_name}"  \
                    '. + { user_name: $user_name }' \
                  <<< "${tmpl_data}")"

    echo '  create user secrets configuration file:'

    # TODO: do not hard-code file suffix
    path_to_temp_file="${path_to_secrets_folder}/${user_name}.yaml.temp"
    echo "${path_to_conf_file}"

    echo -n '  render template into configuration file: '

    if output="$(j2 --format json "${path_to_tmpl_folder}/${user_sec_tmpl}" \
                  <<< "${tmpl_data}" 2>&1)"
    then
        echo 'OK'
        echo "${output}" > "${path_to_temp_file}"
    else
        echo 'ERROR'
        echo "  ${output}"
        exit 1
    fi
    echo

    # move temp file to conf file
    if ! output="$(mv "${path_to_temp_file}" "${path_to_conf_file}" 2>&1)"
    then
        echo "${output}"
        exit 1
    fi

    echo "  file created: ${path_to_conf_file}"
done


if ! popd > /dev/null
then
    echo "failed to popd from project root ${path_to_project_root}"
    exit
fi


echo
echo 'HashiCorp Vault secrets file creation complete'
echo
