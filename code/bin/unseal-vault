#!/usr/bin/env bash

# unseal-vault
#
# open vault so users can log in and read / write secrets
#
# author  : stefan schablowski
# contact : stefan.schablowski@desmodyne.com
# created : 2018-02-19


# https://www.vaultproject.io/api/system/unseal.html

# TODO: move this to formal documentation of how these scripts work
# NOTE: this script requires key information in json format;
# this information is displayed by a vault only once, when it is initialized
# and - as per convention - is stored as init.json in a secure location


# -----------------------------------------------------------------------------
# load functions from library and run as appropriate

# see also build-vault

source vault.lib

if ! determine_platform;            then exit 1; fi
if ! proc_cmd_line_args "$@";       then exit 1; fi


# -----------------------------------------------------------------------------
# load script configuration

# NOTE: see config file for parameter documentation
# TODO: error handling, e.g. check if key_file is available
# TODO: review output, message only if error or -v / --verbose

# http://mikefarah.github.io/yq
config="$(yq r "${config_file}")"

vault_address="$(  yq r - vault_address   <<< "${config}")"
path_to_sec_loc="$(yq r - path_to_sec_loc <<< "${config}")"
key_file_name="$(  yq r - key_file_name   <<< "${config}")"


# -----------------------------------------------------------------------------
# configure script parameters

# full path to file with key and token info
path_to_key_file="${path_to_sec_loc}/${key_file_name}"


# -----------------------------------------------------------------------------
# unseal vault

echo -n 'Get vault status: '

# NOTE: from vault status --help:
#   The exit code reflects the seal status:
#       - 0 - unsealed
#       - 1 - error
#       - 2 - sealed

output="$(vault status -address="${vault_address}" 2>&1)"
res=$?
if   [ "${res}" = 0 ]
then
    echo 'OK'
    echo "Vault at ${vault_address} is already unsealed"
    exit "${res}"
elif [ "${res}" = 1 ]
then
    echo 'ERROR'
    echo "${output}"
    exit "${res}"
else
    echo 'OK'
fi

echo 'Unseal vault:'

number_of_keys="$(jq '.keys | length' "${path_to_key_file}")"

# bash brace expansion does not support variables
for key_index in $(seq 0 $((number_of_keys - 1)))
do
    echo -n "  send key #${key_index}: "
    key="$(jq -r ".keys[${key_index}]" "${path_to_key_file}")"
    if output="$(curl --data   "{\"key\": \"${key}\"}"  \
                      --request PUT                     \
                      --show-error                      \
                      --silent                          \
                      "${vault_address}/v1/sys/unseal" 2>&1)"
    then
        # if successful, curl returns 0 and
        # output is json with unseal status

        # sample success response:
        # {
        #   "type": "shamir",
        #   "sealed": true,
        #   "t": 3,
        #   "n": 5,
        #   "progress": 1,
        #   "nonce": "60707b37-dc3c-a3f1-720c-d9475ff12a65",
        #   "version": "0.9.3"
        # }
        # TODO: better success detection - how about success: true in response ?
        if progress="$(jq -r '.progress' <<< "${output}" 2>&1)" && \
           total="$(   jq -r '.t'        <<< "${output}" 2>&1)"
        then
            echo "OK - ${progress} / ${total}"

        # sample error response:
        # { "errors" : [ "1 error occurred:\n\n* permission denied" ] }
        else
            if errors="$(jq -r '.errors[]' <<< "${output}" 2>&1)"
            then
                echo 'ERROR'
                echo "${errors}"
            else
                echo 'ERROR'
                echo "${output}"
            fi
            exit 1
        fi
    else
        echo 'ERROR'
        echo "${output}"
        exit 1
    fi

    sealed="$(jq '.sealed' <<< "${output}")"
    if [ "${sealed}" = 'false' ]
    then
        break
    fi
done

if [ "${sealed}" = 'false' ]
then
    echo 'Vault has been unsealed'
    exit 0
else
    echo 'Failed to unsealed vault'
    exit 1
fi
