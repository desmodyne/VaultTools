#!/usr/bin/env bash

# create-secrets-files
#
# generate configuration files for vault secrets in secure location
#
# author  : stefan schablowski
# contact : stefan.schablowski@desmodyne.com
# created : 2018-02-22


# -----------------------------------------------------------------------------
# load functions from library and run as appropriate

# see also build-vault

source vault.lib

if ! determine_platform;            then exit 1; fi
if ! proc_cmd_line_args "$@";       then exit 1; fi


# -----------------------------------------------------------------------------
# load script configuration

# NOTE: see config file for parameter documentation
# TODO: error handling, e.g. check if path_to_sec_loc is available
# TODO: review output, message only if error or -v / --verbose

echo 'Load script configuration:'

# http://mikefarah.github.io/yq
config="$(yq r "${config_file}")"

# TODO: align with PKI scripts, get the first two from Ansible group vars

mgmt_user_name="$(    yq r - mgmt_user_name     <<< "${config}")"
organization="$(      yq r - organization       <<< "${config}")"
path_to_sec_loc="$(   yq r - path_to_sec_loc    <<< "${config}")"
path_to_pki_folder="$(yq r - path_to_pki_folder <<< "${config}")"
secrets_folder="$(    yq r - secrets_folder     <<< "${config}")"
placeholder="$(       yq r - placeholder        <<< "${config}")"

# TODO: yq fails to support accessing substructures, so use jq
secrets_json="$(   yq -j r - secrets  <<< "${config}")"
services_json="$(  yq -j r - services <<< "${config}")"
users_json="$(     yq -j r - users    <<< "${config}")"

# TODO: review jq exprs to make these scalable beyond one path

# json data structure with secrets for each service
service_secrets_json="$(jq '.[] | select(.context=="service")' <<< "${secrets_json}")"

# json data structure with secrets for each user
user_secrets_json="$(   jq '.[] | select(.context=="user")'    <<< "${secrets_json}")"

echo


# -----------------------------------------------------------------------------
# validate config settings

echo -n 'Validate configuration settings: '

# TODO: verify path_to_sec_loc is an absolute path ?
# TODO: resolve symbolic links into real path ?

if [ -e "${path_to_sec_loc}" ]
then
    if [ -d "${path_to_sec_loc}" ]
    then
        echo 'OK'
        echo
    else
        echo 'ERROR'
        echo '  Path exists, but is not a directory:'
        echo "  ${path_to_sec_loc}"
        exit 1
    fi
else
    # split paths into its components
    # https://askubuntu.com/a/600252
    # TODO: this fails with whitespace in path
    comps="$("${xargs}" -n 1 -d '/' <<< "${path_to_sec_loc}" | "${xargs}")"

    # turn path components into array
    # https://stackoverflow.com/a/13402368
    # NOTE: word splitting is intended here
    # shellcheck disable=SC2206
    array=(${comps})

    # NOTE: alternate / shorter approach:
    # https://github.com/koalaman/shellcheck/wiki/SC2207
    # mapfile -t array < \
    #     <("${xargs}" -n 1 -d '/' <<< "${path_to_sec_loc}" | "${xargs}")

    # if at least the first two path components exist,
    # they are considered a solid base for the rest
    # TODO: this is specific to local secure location
    # TODO: this assumes at least two comps in path
    if [ -d "/${array[0]}/${array[1]}" ]
    then
        echo 'OK'
        echo
    else
        echo 'ERROR'
        echo '  Path to secure location is not mounted:'
        echo "  ${path_to_sec_loc}"
        exit 1
    fi
fi


# -----------------------------------------------------------------------------
# configure script parameters

# absolute path to this script: http://stackoverflow.com/a/9107028
path_to_this_script="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# path from this script to project root
rel_path_to_project_root='../..'

# absolute path to project root
path_to_project_root="$(realpath \
                        "${path_to_this_script}/${rel_path_to_project_root}")"

# absolute path to folder with secrets configuration files
path_to_secrets_folder="${path_to_sec_loc}/${secrets_folder}"

# path to folder with templates, relative to project root
path_to_tmpl_folder='data/tmpl'

# name of service secret template file
srv_sec_tmpl='service_secret.yaml.j2'

# name of user secret template file
user_sec_tmpl='user_secret.yaml.j2'

# organization name is used in lower case
organization="$(tr '[:upper:]' '[:lower:]' <<< "${organization}")"

# template for managent user private ssh key filename
# sample name: id_rsa_desmodyne_ansible_ssc_rs
mgmt_key_filename_tmpl="id_rsa_${organization}_${mgmt_user_name}_%s_rs"

# template for personal private ssh key filename
# sample name: id_rsa_desmodyne_ssc_rs
pers_key_filename_tmpl="id_rsa_${organization}_%s_rs"

# jq expression template to get service secrets from existing secrets file
# NOTE: secret/user/ must be in sync with .../data/tmpl/user_secret.yaml.j2
jq_expr_tmpl_serv='.[] | from_entries | .secrets | from_entries | .%s'

# jq expression template to get user passwords from existing secrets file
# NOTE: secret/user/ must be in sync with .../data/tmpl/user_secret.yaml.j2
jq_expr_tmpl_user='.[] | from_entries | select(.path=="secret/user/%s") '
jq_expr_tmpl_user+='| .secrets | from_entries | .password'


# -----------------------------------------------------------------------------
# create secrets configuration file


if ! pushd "${path_to_project_root}" > /dev/null
then
    echo "Failed to pushd to project root ${path_to_project_root}"
    exit
fi


# see also init-vault for some more information

echo -n 'Verify secure location is under version control: '
if output="$(git -C "${path_to_sec_loc}" rev-parse --git-dir)"
then
    echo 'OK'
else
    echo 'ERROR'
    echo "${output}"
    exit 1
fi

# if the repo is not clean to prevent overwriting changes
echo -n 'Verify secure location repository status: '
if output="$(git -C "${path_to_sec_loc}" status --porcelain)"
then

    if [ -z "${output}" ]
    then
        echo 'OK'
    else
        echo 'ERROR'
        echo 'Repository has uncommitted changes:'
        echo "${output}"
        exit 1
    fi
else
    echo 'ERROR'
    echo "${output}"
    exit 1
fi

if [ ! -d "${path_to_secrets_folder}" ]
then
    echo -n 'Create secrets configuration folder: '
    if output="$(mkdir -p "${path_to_secrets_folder}" 2>&1)"
    then
        echo 'OK'
        echo
    else
        echo 'ERROR'
        echo "${output}"
        exit 1
    fi
fi

# TODO: continue or exit ?
# TODO: remove code duplication

if [ "${services_json}" != 'null' ]
then
    services="$(jq -r '.[].name' <<< "${services_json}" | xargs)"
fi

for service in ${services}
do
    # secrets json data structure as obtained from conf file:
    #   "secrets":
    #   [
    #     "admin_password",
    #     "reader_password",
    #     "user_password",
    #     "root_password"
    #   ]
    #
    # secrets json data structure as needed to render template:
    #   "secrets":
    #   {
    #     "admin_password": <existing password> or <placeholder> (i.e. "TODO"),
    #     "reader_password": <existing password> or <placeholder> (i.e. "TODO"),
    #     "user_password": <existing password> or <placeholder> (i.e. "TODO"),
    #     "root_password": <existing password> or <placeholder> (i.e. "TODO")
    #   }

    echo 'Add known secrets to template data:'

    # TODO: do not hard-code file suffix
    path_to_conf_file="${path_to_secrets_folder}/${service}.yaml"

    num_of_sec_confs="$(jq -r '.sec_confs | length' <<< "${service_secrets_json}")"

    tmpl_data="${service_secrets_json}"

    for index in $(seq 0 "$((num_of_sec_confs - 1))")
    do
        secret_keys="$(jq -r ".sec_confs[${index}].secrets[]" \
                        <<< "${service_secrets_json}" | xargs)"

        secrets_json_map='{}'

        for secret_key in ${secret_keys}
        do
            secret_value="${placeholder}"

            # attempt to get secret from existing file
            if [ -f "${path_to_conf_file}" ]
            then
                # shellcheck disable=SC2059
                jq_expr="$(printf "${jq_expr_tmpl_serv}" "${secret_key}")"

                if output="$(yq r -j "${path_to_conf_file}" \
                             | jq -r "${jq_expr}"  2>&1)"
                then
                    secret_value="${output}"
                fi
            fi

            # extend json object:      https://stackoverflow.com/q/31694182
            # parentheses around $key: https://stackoverflow.com/a/35842157
            secrets_json_map="$(jq --arg key   "${secret_key}"    \
                                   --arg value "${secret_value}"  \
                                   '. += { ($key): $value }' \
                                 <<< "${secrets_json_map}")"
        done

        # replace secrets array in template data with secrets object
        tmpl_data="$(jq --argjson secrets "${secrets_json_map}"     \
                        ".sec_confs[${index}].secrets = \$secrets"  \
                      <<< "${tmpl_data}")"
    done

    # add service to template data
    service_secrets_json="$(jq --arg  service "${service}" \
                               '. + { service: $service }' \
                                <<< "${service_secrets_json}")"

    echo "Create service secrets configuration file:"

    # TODO: do not hard-code file suffix
    path_to_temp_file="${path_to_secrets_folder}/${username}.yaml.temp"
    echo "${path_to_conf_file}"

    echo -n "Render template into configuration file: "

    if output="$(j2 --format json "${path_to_tmpl_folder}/${srv_sec_tmpl}" \
                              <<< "${tmpl_data}" 2>&1)"
    then
        echo 'OK'
        echo "${output}" > "${path_to_temp_file}"
    else
        echo 'ERROR'
        echo "${output}"
        exit 1
    fi
    echo

    # move temp file to conf file
    if ! output="$(mv "${path_to_temp_file}" "${path_to_conf_file}" 2>&1)"
    then
        echo "${output}"
        exit 1
    fi
done


if [ "${users_json}" != 'null' ]
then
    usernames="$(jq -r '.[].name' <<< "${users_json}" | xargs)"
fi

for username in ${usernames}
do
    # secrets json data structure as obtained from conf file:
    #   "secrets":
    #   [
    #     "password",
    #     "private_key",
    #     "public_key"
    #   ]
    #
    # secrets json data structure as needed to render template:
    #   "secrets":
    #   {
    #     "password": <existing password> or <placeholder> (i.e. "TODO"),
    #     "private_key": "(multi-line!) <private key>"
    #     "public_key": "<public key>",
    #   }

    echo 'Add known secrets to template data:'

    # TODO: do not hard-code file suffix
    path_to_conf_file="${path_to_secrets_folder}/${username}.yaml"

    num_of_sec_confs="$(jq -r '.sec_confs | length' <<< "${user_secrets_json}")"

    tmpl_data="${user_secrets_json}"

    for index in $(seq 0 "$((num_of_sec_confs - 1))")
    do
        password="${placeholder}"

        secret_keys="$(jq -r ".sec_confs[${index}].secrets[]" \
                        <<< "${user_secrets_json}" | xargs)"
        secret_path="$(jq -r ".sec_confs[${index}].path" \
                        <<< "${user_secrets_json}")"

        if   [ "${secret_path}" = 'null' ]
        then
            # attempt to get user password from existing file
            if [ -f "${path_to_conf_file}" ]
            then
                # shellcheck disable=SC2059
                jq_expr="$(printf "${jq_expr_tmpl_user}" "${username}")"

                if output="$(yq r -j "${path_to_conf_file}" \
                             | jq -r "${jq_expr}"  2>&1)"
                then
                    password="${output}"
                fi
            fi

            # shellcheck disable=SC2059
            path_to_private_key="$(printf \
              "${path_to_pki_folder}/${pers_key_filename_tmpl}"     \
              "${username}")"
            # shellcheck disable=SC2059
            path_to_public_key="$(printf  \
              "${path_to_pki_folder}/${pers_key_filename_tmpl}.pub" \
              "${username}")"

        # NOTE: path must be in sync with .../data/tmpl/user_secret.yaml.j2
        elif [ "${secret_path}" = "shared_users/${mgmt_user_name}" ]
        then
            # attempt to get management user password from existing file
            if [ -f "${path_to_conf_file}" ]
            then
                # shellcheck disable=SC2059
                jq_expr="$(printf "${jq_expr_tmpl_user}" \
                                  "${username}/shared_users/${mgmt_user_name}")"

                if output="$(yq r -j "${path_to_conf_file}" \
                             | jq -r "${jq_expr}"  2>&1)"
                then
                    password="${output}"
                fi
            fi

            # shellcheck disable=SC2059
            path_to_private_key="$(printf \
              "${path_to_pki_folder}/${mgmt_key_filename_tmpl}"     \
              "${username}")"
            # shellcheck disable=SC2059
            path_to_public_key="$(printf  \
              "${path_to_pki_folder}/${mgmt_key_filename_tmpl}.pub" \
              "${username}")"

        else
            echo "Unexpected secrets path ${secret_path}"
            exit 1
        fi

        # re-format private and public key
        # https://stackoverflow.com/a/3182519
        tmp_file_contents=$'|\n'
        tmp_file_contents+="$(sed -e 's/^/      /' "${path_to_private_key}")"
        private_key="${tmp_file_contents}"
        tmp_file_contents=$'|\n'
        tmp_file_contents+="$(sed -e 's/^/      /' "${path_to_public_key}" )"
        public_key="${tmp_file_contents}"

        # empty secrets json data structure
        secrets_json_map='{}'

        for secret_key in ${secret_keys}
        do
            case "${secret_key}" in
                password)
                    secret_value="${password}"
                    ;;
                public_key)
                    secret_value="${public_key}"
                    ;;
                private_key)
                    secret_value="${private_key}"
                    ;;
                *)
                    echo "Unexpected secret key ${secret_key}"
                    exit 1
            esac

            # extend json object:      https://stackoverflow.com/q/31694182
            # parentheses around $key: https://stackoverflow.com/a/35842157
            secrets_json_map="$(jq --arg key   "${secret_key}"    \
                                   --arg value "${secret_value}"  \
                                   '. += { ($key): $value }' \
                                 <<< "${secrets_json_map}")"
        done

        # replace secrets array in template data with secrets object
        tmpl_data="$(jq --argjson secrets "${secrets_json_map}"     \
                        ".sec_confs[${index}].secrets = \$secrets"  \
                      <<< "${tmpl_data}")"
    done

    # add username to template data
    tmpl_data="$(jq --arg username "${username}"  \
                    '. + { username: $username }' \
                  <<< "${tmpl_data}")"

    echo "Create user secrets configuration file:"

    # TODO: do not hard-code file suffix
    path_to_temp_file="${path_to_secrets_folder}/${username}.yaml.temp"
    echo "${path_to_conf_file}"

    echo -n "Render template into configuration file: "

    if output="$(j2 --format json "${path_to_tmpl_folder}/${user_sec_tmpl}" \
                  <<< "${tmpl_data}" 2>&1)"
    then
        echo 'OK'
        echo "${output}" > "${path_to_temp_file}"
    else
        echo 'ERROR'
        echo "${output}"
        exit 1
    fi
    echo

    # move temp file to conf file
    if ! output="$(mv "${path_to_temp_file}" "${path_to_conf_file}" 2>&1)"
    then
        echo "${output}"
        exit 1
    fi
done


if ! popd > /dev/null
then
    echo "Failed to popd from project root ${path_to_project_root}"
    exit
fi
