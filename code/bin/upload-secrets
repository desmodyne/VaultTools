#!/usr/bin/env bash

# upload-secrets
#
# create secrets on the vault server
#
# author  : stefan schablowski
# contact : stefan.schablowski@desmodyne.com
# created : 2018-02-22


# https://www.vaultproject.io/docs/commands/write.html
# https://www.vaultproject.io/intro/getting-started/first-secret.html


# -----------------------------------------------------------------------------
# load functions from library and run as appropriate

# see also build-vault

source vault.lib

if ! determine_platform;            then exit 1; fi
if ! proc_cmd_line_args "$@";       then exit 1; fi


# -----------------------------------------------------------------------------
# load script configuration

# NOTE: see config file for parameter documentation
# TODO: error handling, e.g. check if key_file is available
# TODO: review output, message only if error or -v / --verbose

# http://mikefarah.github.io/yq
config="$(yq r "${config_file}")"

vault_address="$(   yq r - vault_address    <<< "${config}")"
path_to_sec_loc="$( yq r - path_to_sec_loc  <<< "${config}")"
key_file_name="$(   yq r - key_file_name    <<< "${config}")"
secrets_folder="$(  yq r - secrets_folder   <<< "${config}")"
placeholder="$(     yq r - placeholder      <<< "${config}")"

# TODO: yq fails to support accessing substructures, so use jq
services_json="$(   yq -j r - services      <<< "${config}")"
users_json="$(      yq -j r - users         <<< "${config}")"


# -----------------------------------------------------------------------------
# configure script parameters

# full path to file with key and token info
path_to_key_file="${path_to_sec_loc}/${key_file_name}"


# -----------------------------------------------------------------------------
get_vault_status
res=$?
case "${res}" in
    0)  #
        ;;
    1)  # error message is displayed by get_vault_status
        ;;
    2)  echo "Vault at ${vault_address} is sealed; please unseal and try again"
        ;;
    3)  echo "Vault at ${vault_address} is not yet initialized"
        ;;
esac

if [ "${res}" != 0 ]
then
    exit
fi


# -----------------------------------------------------------------------------
# upload secrets

# https://www.vaultproject.io/api/secret/kv/index.html

root_token="$(jq -r '.root_token' "${path_to_key_file}")"

echo -n 'Log into vault: '
if output="$(vault login -address="${vault_address}" "${root_token}" 2>&1)"
then
    echo 'OK'
else
    echo 'ERROR'
    echo "${output}"
    exit 1
fi

# TODO: remove code duplication

if [ "${services_json}" != 'null' ]
then
    services="$(jq -r '.[].name' <<< "${services_json}" | xargs)"
fi

for service in ${services}
do
    # TODO: do not hard-code file suffix
    # TODO: really mix service and user secret files in the same folder ?
    path_to_conf_file="${path_to_sec_loc}/${secrets_folder}/${service}.yaml"

    echo "Upload secrets for service ${service}:"

    # load entire service secrets conf file
    # NOTE: yq does return json, but in jq "entries" format
    jq_expr='.[] | from_entries | .secrets = (.secrets | from_entries)'
    secrets_conf="$(yq -j r "${path_to_conf_file}" | jq "${jq_expr}")"

    paths="$(jq -r '.path' <<< "${secrets_conf}")"

    for path in ${paths}
    do
        # TODO: is it safe to show paths in output ?
        echo -n "  Path ${path}: "

        jq_expr="select(.path == \"${path}\").secrets"
        secrets="$(jq -r "${jq_expr}" <<< "${secrets_conf}")"

        unset_secrets=false
        OLD_IFS="${IFS}" && IFS=$'\n'

        # verify all secrets were changed after file was generated
        # https://ilya-sher.org/2016/05/11/most-jq-you-will-ever-need
        #  --> search for 'Do something with each object'
        # NOTE: while loop as on page above, unset_secrets is not set
        json_lines="$(jq -c 'to_entries[]' <<< "${secrets}")"
        for json_line in ${json_lines}
        do
            key="$(  jq -r '.key'   <<< "${json_line}")"
            value="$(jq -r '.value' <<< "${json_line}")"
            if [ "${value}" = "${placeholder}" ]
            then
                echo 'ERROR'
                echo "Secret ${path}/${key} has not been set"
                unset_secrets=true
                break
            fi
        done

        IFS="${OLD_IFS}"

        if [ "${unset_secrets}" = true ]
        then
            continue
        fi

        if output="$(curl --data   "${secrets}"                   \
                          --header "X-Vault-Token: ${root_token}" \
                          --request POST                          \
                          --show-error                            \
                          --silent                                \
                          "${vault_address}/v1/${path}" 2>&1)"
        then
            # if successful, curl returns 0 and output is empty
            if [ -z "${output}" ]
            then
                echo 'OK'
            else
                echo 'ERROR'
                # sample output:
                # {"errors":["1 error occurred:\n\n* permission denied"]}
                if errors="$(jq -r '.errors[]' <<< "${output}" 2>&1)"
                then
                    echo "${errors}"
                else
                    echo "${output}"
                fi
                exit 1
            fi
        else
            echo 'ERROR'
            echo "${output}"
            exit 1
        fi
    done
done

if [ "${users_json}" != 'null' ]
then
    usernames="$(jq -r '.[].name' <<< "${users_json}" | xargs)"
fi

for username in ${usernames}
do
    # TODO: do not hard-code file suffix
    path_to_conf_file="${path_to_sec_loc}/${secrets_folder}/${username}.yaml"

    echo "Upload secrets for user ${username}:"

    # load entire user secrets conf file
    # NOTE: yq does return json, but in jq "entries" format
    jq_expr='.[] | from_entries | .secrets = (.secrets | from_entries)'
    secrets_conf="$(yq -j r "${path_to_conf_file}" | jq "${jq_expr}")"

    paths="$(jq -r '.path' <<< "${secrets_conf}")"

    for path in ${paths}
    do
        # TODO: is it safe to show paths in output ?
        echo -n "  Path ${path}: "

        jq_expr="select(.path == \"${path}\").secrets"
        secrets="$(jq -r "${jq_expr}" <<< "${secrets_conf}")"

        unset_secrets=false
        OLD_IFS="${IFS}" && IFS=$'\n'

        # verify all secrets were changed after file was generated
        # https://ilya-sher.org/2016/05/11/most-jq-you-will-ever-need
        #  --> search for 'Do something with each object'
        # NOTE: while loop as on page above, unset_secrets is not set
        json_lines="$(jq -c 'to_entries[]' <<< "${secrets}")"
        for json_line in ${json_lines}
        do
            key="$(  jq -r '.key'   <<< "${json_line}")"
            value="$(jq -r '.value' <<< "${json_line}")"
            if [ "${value}" = "${placeholder}" ]
            then
                echo 'ERROR'
                echo "Secret ${path}/${key} has not been set"
                unset_secrets=true
                break
            fi
        done

        IFS="${OLD_IFS}"

        if [ "${unset_secrets}" = true ]
        then
            continue
        fi

        if output="$(curl --data   "${secrets}"                   \
                          --header "X-Vault-Token: ${root_token}" \
                          --request POST                          \
                          --show-error                            \
                          --silent                                \
                          "${vault_address}/v1/${path}" 2>&1)"
        then
            # if successful, curl returns 0 and output is empty
            if [ -z "${output}" ]
            then
                echo 'OK'
            else
                echo 'ERROR'
                # sample output:
                # {"errors":["1 error occurred:\n\n* permission denied"]}
                if errors="$(jq -r '.errors[]' <<< "${output}" 2>&1)"
                then
                    echo "${errors}"
                else
                    echo "${output}"
                fi
                exit 1
            fi
        else
            echo 'ERROR'
            echo "${output}"
            exit 1
        fi
    done
done
